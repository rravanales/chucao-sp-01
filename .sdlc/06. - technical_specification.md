# Especificación Técnica Integral para la Implementación de DeltaOne

## 1. Introducción

### 1.1 Propósito

El propósito de este documento es proporcionar una especificación técnica exhaustiva para la **implementación inicial y esencial de DeltaOne**. Esta implementación busca establecer una plataforma integral y estandarizada para la **configuración y gestión centralizada de Scorecards y KPIs**. Servirá como una guía precisa para los equipos de ingeniería, arquitectura de software y diseño de UI/UX, detallando las interacciones esperadas entre los usuarios y el sistema para satisfacer las necesidades de negocio de manera eficiente y estandarizada.

### 1.2 Alcance del Proyecto

El proyecto se centrará en las **funcionalidades clave y esenciales de DeltaOne** para la gestión del desempeño estratégico. El alcance incluye:

*   **Configuración y gestión de Scorecards y KPIs**: Implementación de la estructura, definición y configuración de KPIs (tipos de puntuación como Goal/Red Flag, Sí/No, Texto), actualizaciones manuales y cálculos automáticos, asignación de propietarios y gestión de ponderaciones, y auditoría de cálculos.
*   **Implementación de importaciones de datos solo para KPIs**: Configuración de importaciones desde hojas de cálculo (Excel) y bases de datos (Microsoft SQL Server, Oracle, MySQL, PostgreSQL, Hive), incluyendo conexiones, transformación de datos y programación de importaciones recurrentes.
*   **Configuración de Alertas para eventos específicos de KPI y notas**: Alertas automáticas para KPIs en estado "Rojo", recordatorios de actualización, alertas por respuestas a notas y requerimiento de notas para bajo rendimiento.
*   **Administración de usuarios, grupos y permisos con personalización de terminología**: Configuración de usuarios individuales e importación masiva, gestión de grupos (Power Users, Update Users, Interactive Users, View Only), asignación de permisos basados en la organización y personalización de la terminología de la aplicación.
*   **Organizaciones**: Configuración de la jerarquía organizacional, implementación de KPIs de rollup y configuración de organizaciones basadas en plantillas a partir de campos de datasets, e integración de permisos organizacionales con grupos de árboles de rollup.

**Exclusiones del Alcance para esta fase inicial**:

*   Importaciones de datos para Iniciativas y Servicios Web (Zapier, REST API).
*   Configuración y uso detallado de Dashboards, Charts, Reports, Datasets (más allá de lo requerido para soportar KPIs) y Forms.
*   Configuración avanzada de seguridad de red o VPN, siendo responsabilidad del cliente auto-hospedado.
*   Integración personalizada con otros sistemas de la empresa, más allá de las importaciones de KPIs de bases de datos/hojas de cálculo.
*   Capacitación detallada de usuarios finales en todas las funcionalidades avanzadas de la plataforma (el proyecto se centrará en el "back-end" y funcionalidades básicas).

### 1.3 Pila Tecnológica

La aplicación se construirá utilizando la siguiente pila tecnológica:

*   **Frontend**: Next.js, Tailwind CSS, Shadcn/UI, Framer Motion.
*   **Backend**: PostgreSQL, Supabase, Drizzle ORM, Server Actions.
*   **Autenticación**: Clerk.
*   **Pagos**: Stripe.
*   **Despliegue**: Vercel.

## 2. Arquitectura del Sistema

### 2.1 Visión General de la Arquitectura

La aplicación se basará en una arquitectura Next.js robusta, que aprovecha las **capacidades de Server Components y Server Actions** para un renderizado eficiente y operaciones de datos seguras. Clerk se integrará para la autenticación de usuarios, Drizzle ORM para la interacción con la base de datos PostgreSQL, y Stripe para la gestión de pagos y suscripciones.

### 2.2 Componentes Principales

*   **Next.js Application (Monorepo)**: Contiene el frontend y el backend (Server Actions).
*   **Clerk (Auth)**: Proveedor de autenticación para la gestión de usuarios, sesiones y seguridad.
*   **PostgreSQL Database**: Base de datos relacional para almacenar todos los datos de la aplicación.
*   **Drizzle ORM**: Interfaz para interactuar con la base de datos PostgreSQL de forma tipada y segura.
*   **Stripe**: Para la gestión de suscripciones y webhooks de pago.
*   **Vercel**: Plataforma de despliegue para la aplicación.
*   **Servidor SMTP**: Para el envío de notificaciones por correo electrónico.

### 2.3 Flujo de Datos

1.  **Carga Inicial**: Los **Server Components** de Next.js obtendrán los datos iniciales directamente de la base de datos a través de Drizzle ORM o Server Actions.
2.  **Autenticación**: El middleware de Clerk protegerá las rutas y gestionará la autenticación del usuario. Si un `userId` autenticado no tiene un perfil en la DB, se creará uno automáticamente.
3.  **Interacciones del Usuario**: Los **Client Components** interactuarán con la UI.
4.  **Mutaciones de Datos**: Cualquier operación que modifique datos (crear, actualizar, eliminar) será manejada exclusivamente por **Server Actions**. Estas acciones realizarán validaciones, lógica de negocio y se comunicarán con la base de datos a través de Drizzle ORM. Todas las Server Actions devolverán un `ActionState<T>` para una respuesta estandarizada.
5.  **Actualización de UI**: Después de una mutación exitosa a través de una Server Action, los componentes cliente podrán revalidar los datos o actualizar su estado local para reflejar los cambios. Se utilizarán `router.refresh()` o re-fetching de datos para actualizaciones. Las notificaciones al usuario se gestionarán con el hook `useToast`.
6.  **Programación**: Las tareas programadas (ej. importaciones, alertas) se gestionarán mediante **Vercel Cron Jobs** que invocarán API routes, las cuales a su vez llamarán a Server Actions específicas para su ejecución.
7.  **Alertas**: Las alertas se enviarán por correo electrónico usando SMTP y como notificaciones dentro de la aplicación.

## 3. Estructura del Proyecto y Organización de Código

El proyecto seguirá la estructura de directorios definida en el `starter_template.md` y las reglas del `project_rules.md`.

### 3.1 Estructura de Directorios

```
└── rravanales-chucao-sp-01/
    ├── actions/
    │   ├── db/
    │   │   ├── profiles-actions.ts  (Existente)
    │   │   ├── scorecard-actions.ts
    │   │   ├── kpi-actions.ts
    │   │   ├── import-actions.ts
    │   │   ├── alert-actions.ts
    │   │   ├── user-group-actions.ts
    │   │   └── organization-actions.ts
    │   └── stripe-actions.ts        (Existente)
    ├── app/
    │   ├── (auth)/                  (Existente)
    │   ├── (marketing)/             (Existente)
    │   └── (main)/                  (Nuevo grupo para la app principal, protegido por auth)
    │       ├── layout.tsx           (Server Layout para la app principal)
    │       ├── dashboard/
    │       │   └── page.tsx         (Server Page, punto de entrada)
    │       ├── scorecards/
    │       │   ├── page.tsx
    │       │   └── _components/     (Componentes específicos de la ruta scorecards)
    │       ├── kpis/
    │       │   └── [kpiId]/
    │       │       └── page.tsx
    │       │       └── _components/
    │       ├── imports/
    │       │   ├── page.tsx
    │       │   └── _components/
    │       ├── alerts/
    │       │   ├── page.tsx
    │       │   └── _components/
    │       └── admin/
    │           ├── layout.tsx
    │           ├── users/
    │           │   ├── page.tsx
    │           │   └── _components/
    │           ├── groups/
    │           │   ├── page.tsx
    │           │   └── _components/
    │           ├── organizations/
    │           │   ├── page.tsx
    │           │   └── _components/
    │           └── settings/
    │               ├── page.tsx
    │               └── _components/
    ├── components/                  (Existente)
    │   ├── ui/                      (Existente - Shadcn components)
    │   └── utilities/               (Existente - Providers, ThemeSwitcher, TailwindIndicator)
    ├── db/                          (Existente)
    │   ├── db.ts                    (Existente)
    │   ├── migrations/              (Existente - No modificar)
    │   └── schema/
    │       ├── index.ts             (Existente)
    │       ├── profiles-schema.ts   (Existente)
    │       ├── organizations-schema.ts
    │       ├── scorecard-elements-schema.ts
    │       ├── kpis-schema.ts
    │       ├── kpi-values-schema.ts
    │       ├── kpi-updaters-schema.ts
    │       ├── import-connections-schema.ts
    │       ├── saved-imports-schema.ts
    │       ├── alerts-schema.ts
    │       ├── groups-schema.ts
    │       ├── group-members-schema.ts
    │       ├── group-permissions-schema.ts
    │       └── app-settings-schema.ts
    ├── lib/                         (Existente)
    ├── public/                      (Existente)
    ├── types/                       (Existente)
    │   ├── index.ts                 (Existente)
    │   ├── server-action-types.ts   (Existente)
    │   ├── db-types.ts
    │   ├── ui-types.ts
    │   └── common-types.ts
    └── (Otros archivos de configuración/base existentes)
```

### 3.2 Convenciones de Nomenclatura

*   **General**: Usar `kebab-case` para todos los archivos y carpetas, a menos que se especifique lo contrario.
*   **Server Actions**: Los archivos de Server Actions en `actions/db` y `actions` deben usar `kebab-case` (ej. `profiles-actions.ts`). Las funciones de acción deben terminar con `Action` (ej. `createProfileAction`).
*   **Tipos**: Los archivos de tipos en `types` deben llamarse `ejemplo-types.ts` (ej. `server-action-types.ts`). Preferir interfaces sobre alias de tipo.
*   **Esquemas DB**: Los archivos de esquemas en `db/schema` deben llamarse `ejemplo-schema.ts` (ej. `profiles-schema.ts`).
*   **Componentes**: Los componentes en `_components` y `components` deben llamarse `ejemplo-component.tsx`.

## 4. Diseño del Esquema de Base de Datos

Se utilizará PostgreSQL con Drizzle ORM. Todas las tablas deben incluir columnas `createdAt` y `updatedAt`. Se usarán `pgEnum` para columnas con un conjunto limitado de valores posibles. Las claves foráneas deben utilizar `onDelete: "cascade"` cuando sea apropiado.

### 4.1 Tablas Existentes

*   **`profiles`**: Define el perfil del usuario con `userId` (PK), `membership` (enum: 'free', 'pro'), `stripeCustomerId`, `stripeSubscriptionId`, `createdAt`, `updatedAt`.

### 4.2 Nuevas Tablas Propuestas

*   **`organizations` (Organizaciones)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `name`: `text("name").notNull()`
    *   `description`: `text("description")`
    *   `parent_id`: `uuid("parent_id").references(() => organizations.id, { onDelete: "cascade" })` (Permite jerarquía de N niveles)
    *   `template_from_dataset_field`: `text("template_from_dataset_field")` (Identifica si fue creada por plantilla y de qué campo)
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`scorecard_elements` (Elementos de Scorecard)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `name`: `text("name").notNull()`
    *   `description`: `text("description")`
    *   `parent_id`: `uuid("parent_id").references(() => scorecard_elements.id, { onDelete: "cascade" })` (Permite estructura de árbol)
    *   `organization_id`: `uuid("organization_id").references(() => organizations.id, { onDelete: "cascade" }).notNull()` (Vincula a una organización específica)
    *   `element_type`: `pgEnum("scorecard_element_type", ['Perspective', 'Objective', 'Initiative', 'KPI']).notNull()` (Define el tipo de elemento, 'KPI' estará en la base)
    *   `owner_user_id`: `text("owner_user_id").references(() => profiles.userId, { onDelete: "set null" })` (Referencia al propietario, puede ser nulo)
    *   `weight`: `decimal("weight").default('1.0').notNull()` (Importancia relativa para cálculo de puntuación padre)
    *   `order_index`: `integer("order_index").notNull().default(0)` (Para mantener el orden en la UI)
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`kpis` (Indicadores Clave de Rendimiento)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `scorecard_element_id`: `uuid("scorecard_element_id").references(() => scorecard_elements.id, { onDelete: "cascade" }).notNull().unique()` (FK a `scorecard_elements` con tipo 'KPI')
    *   `scoring_type`: `pgEnum("kpi_scoring_type", ['Goal/Red Flag', 'Yes/No', 'Text']).notNull()`
    *   `calendar_frequency`: `pgEnum("kpi_calendar_frequency", ['Daily', 'Weekly', 'Monthly', 'Quarterly', 'Annually']).notNull()`
    *   `data_type`: `pgEnum("kpi_data_type", ['Number', 'Percentage', 'Currency', 'Text']).notNull()`
    *   `aggregation_type`: `pgEnum("kpi_aggregation_type", ['Sum', 'Average', 'Last Value']).notNull()` (Para agregación temporal y rollup)
    *   `decimal_precision`: `integer("decimal_precision").default(0).notNull()`
    *   `is_manual_update`: `boolean("is_manual_update").default(false).notNull()`
    *   `calculation_equation`: `text("calculation_equation")` (Para KPIs calculados)
    *   `rollup_enabled`: `boolean("rollup_enabled").default(false).notNull()` (Habilita rollup desde organizaciones hijas)
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`kpi_values` (Valores de KPI)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `kpi_id`: `uuid("kpi_id").references(() => kpis.id, { onDelete: "cascade" }).notNull()`
    *   `period_date`: `date("period_date").notNull()` (Fecha del período de actualización)
    *   `actual_value`: `text("actual_value")` (Almacenar como texto para flexibilidad con `data_type`)
    *   `target_value`: `text("target_value")` (nullable)
    *   `threshold_red`: `text("threshold_red")` (nullable)
    *   `threshold_yellow`: `text("threshold_yellow")` (nullable)
    *   `score`: `decimal("score")` (Puntuación calculada, nullable)
    *   `color`: `pgEnum("kpi_color", ['Red', 'Yellow', 'Green'])` (Color calculado, nullable)
    *   `updated_by_user_id`: `text("updated_by_user_id").references(() => profiles.userId, { onDelete: "set null" })`
    *   `is_manual_entry`: `boolean("is_manual_entry").default(false).notNull()`
    *   `note`: `text("note")` (Campo para notas, requerido si el KPI está en "Rojo" y la configuración lo exige)
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`
    *   **Índice Único**: `uniqueIndex("kpi_values_kpi_id_period_date_idx").on(kpi_values.kpi_id, kpi_values.period_date)` (Asegura un único valor por KPI por período)

*   **`kpi_updaters` (Encargados de Actualización de KPI)**
    *   `kpi_id`: `uuid("kpi_id").references(() => kpis.id, { onDelete: "cascade" }).notNull()`
    *   `user_id`: `text("user_id").references(() => profiles.userId, { onDelete: "cascade" }).notNull()`
    *   `can_modify_thresholds`: `boolean("can_modify_thresholds").default(false).notNull()`
    *   **PK Compuesta**: `primaryKey(kpi_id, user_id)`

*   **`import_connections` (Conexiones de Importación)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `name`: `text("name").notNull().unique()`
    *   `connection_type`: `pgEnum("import_connection_type", ['Excel', 'Microsoft SQL Server', 'Oracle', 'MySQL', 'PostgreSQL', 'Hive']).notNull()`
    *   `connection_details`: `jsonb("connection_details").notNull()` (JSON B que contendrá credenciales y detalles de conexión. **Debe ser cifrado a nivel de aplicación.**)
    *   `created_by_user_id`: `text("created_by_user_id").references(() => profiles.userId, { onDelete: "set null" })`
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`saved_imports` (Importaciones Guardadas)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `name`: `text("name").notNull().unique()`
    *   `connection_id`: `uuid("connection_id").references(() => import_connections.id, { onDelete: "cascade" }).notNull()`
    *   `kpi_mappings`: `jsonb("kpi_mappings").notNull()` (Definición de mapeo de columnas de origen a KPIs de destino)
    *   `transformations`: `jsonb("transformations")` (Array de objetos con reglas de transformación)
    *   `schedule_config`: `jsonb("schedule_config")` (Configuración de programación: frecuencia, hora, etc., nullable si no está programada)
    *   `last_run_at`: `timestamp("last_run_at")`
    *   `created_by_user_id`: `text("created_by_user_id").references(() => profiles.userId, { onDelete: "set null" })`
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`alerts` (Alertas)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `alert_type`: `pgEnum("alert_type", ['Red KPI', 'Update Reminder', 'Note Reply', 'Custom KPI Change']).notNull()`
    *   `kpi_id`: `uuid("kpi_id").references(() => kpis.id, { onDelete: "cascade" })` (Nulo para alertas generales como recordatorios de actualización)
    *   `condition_details`: `jsonb("condition_details")` (Ej: umbral, tipo de cambio, si requiere nota)
    *   `recipients_user_ids`: `jsonb("recipients_user_ids").notNull().default('[]')` (Array de `userIds`)
    *   `recipients_group_ids`: `jsonb("recipients_group_ids").notNull().default('[]')` (Array de `groupIds`)
    *   `frequency_config`: `jsonb("frequency_config")` (Ej: 'inmediata', 'diaria', 'semanal', días antes/después)
    *   `created_by_user_id`: `text("created_by_user_id").references(() => profiles.userId, { onDelete: "set null" })`
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`groups` (Grupos de Usuarios)**
    *   `id`: `uuid("id").primaryKey().defaultRandom()`
    *   `name`: `text("name").notNull().unique()`
    *   `group_type`: `pgEnum("user_group_type", ['Power User', 'Update User', 'Interactive User', 'View Only']).notNull()`
    *   `created_at`: `timestamp("created_at").defaultNow().notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

*   **`group_members` (Miembros de Grupo)**
    *   `group_id`: `uuid("group_id").references(() => groups.id, { onDelete: "cascade" }).notNull()`
    *   `user_id`: `text("user_id").references(() => profiles.userId, { onDelete: "cascade" }).notNull()`
    *   **PK Compuesta**: `primaryKey(group_id, user_id)`

*   **`group_permissions` (Permisos de Grupo)**
    *   `group_id`: `uuid("group_id").references(() => groups.id, { onDelete: "cascade" }).notNull()`
    *   `permission_key`: `text("permission_key").notNull()` (Ej: `can_manage_scorecards`, `can_import_data`)
    *   `permission_value`: `boolean("permission_value").default(false).notNull()`
    *   `organization_id`: `uuid("organization_id").references(() => organizations.id, { onDelete: "cascade" })` (Permite permisos a nivel de organización, nulo para permisos globales)
    *   **PK Compuesta**: `primaryKey(group_id, permission_key, organization_id)` (Si `organization_id` es nulo, se considera un permiso global)

*   **`app_settings` (Configuración de la Aplicación)**
    *   `setting_key`: `text("setting_key").primaryKey().notNull()` (Ej: `terminology_measures`, `enable_strategy_maps`)
    *   `setting_value`: `text("setting_value").notNull()` (Valor de la configuración, ej. el término personalizado o 'true'/'false')
    *   `setting_type`: `pgEnum("app_setting_type", ['terminology', 'methodology']).notNull()`
    *   `updated_at`: `timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date())`

### 4.3 Esquemas Drizzle (`db/schema/*.ts`)

Cada tabla definida anteriormente tendrá su propio archivo de esquema en `db/schema/`. Por ejemplo:

**`db/schema/organizations-schema.ts`**
```typescript
import { pgTable, uuid, text, timestamp } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { profilesTable } from "./profiles-schema";

export const organizationsTable = pgTable("organizations", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull(),
  description: text("description"),
  parentId: uuid("parent_id").references(() => organizationsTable.id, { onDelete: "cascade" }),
  templateFromDatasetField: text("template_from_dataset_field"), // Stores the dataset field name used for template creation
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date()),
});

export const organizationsRelations = relations(organizationsTable, ({ many, one }) => ({
  parent: one(organizationsTable, {
    fields: [organizationsTable.parentId],
    references: [organizationsTable.id],
  }),
  children: many(organizationsTable),
  scorecardElements: many(scorecardElementsTable), // Assuming scorecardElementsTable is defined
}));

export type InsertOrganization = typeof organizationsTable.$inferInsert;
export type SelectOrganization = typeof organizationsTable.$inferSelect;
```

**`db/schema/index.ts`**
Debe exportar todos los esquemas:
```typescript
export * from "./profiles-schema";
export * from "./organizations-schema";
// ... (export all other new schemas)
```

**`db/db.ts`**
Añadir los nuevos esquemas al objeto `schema`:
```typescript
import { profilesTable } from "@/db/schema";
// ... (import all new schema tables)
import { organizationsTable } from "@/db/schema/organizations-schema"; // Example
// ...

const schema = {
  profiles: profilesTable,
  organizations: organizationsTable, // New
  // ... (add all other new tables)
};
```

## 5. Server Actions y Lógica de Negocio

Todas las Server Actions deben ser **`"use server"`** y retornar `Promise<ActionState<T>>`. Se utilizará `auth()` de Clerk para obtener el `userId`. Para columnas de tipo fecha/hora, siempre se convertirán objetos `Date` a cadenas ISO (`.toISOString()`) antes de las operaciones de base de datos.

### 5.1 Gestión de Scorecards y KPIs (actions/db/scorecard-actions.ts, kpi-actions.ts)

*   **UC-100: Gestionar Estructura de Scorecards**
    *   **Funciones**: `createScorecardElementAction`, `updateScorecardElementAction`, `deleteScorecardElementAction`, `reorderScorecardElementsAction`, `importScorecardElementsAction`.
    *   **Lógica**:
        *   Validación de unicidad del nombre a nivel jerárquico.
        *   Manejo de la jerarquía (padre/hijo).
        *   Actualización de la tabla `scorecard_elements`.
        *   Para importación masiva: Parsear archivo Excel, validar datos y realizar inserciones/actualizaciones en lote.
    *   **Ejemplo de Función**:
        ```typescript
        // actions/db/scorecard-actions.ts
        "use server";
        import { db } from "@/db/db";
        import { scorecardElementsTable, InsertScorecardElement, SelectScorecardElement } from "@/db/schema/scorecard-elements-schema";
        import { ActionState } from "@/types";
        import { and, eq } from "drizzle-orm";
        import { auth } from "@clerk/nextjs/server";

        export async function createScorecardElementAction(
          data: Omit<InsertScorecardElement, "id" | "createdAt" | "updatedAt" | "ownerUserId">
        ): Promise<ActionState<SelectScorecardElement>> {
          const { userId } = auth();
          if (!userId) return { isSuccess: false, message: "Unauthorized" };

          try {
            // Business Rule: Each scorecard element must have a unique name within its hierarchical level.
            if (data.parentId) {
                const existingElement = await db.query.scorecardElements.findFirst({
                    where: and(
                        eq(scorecardElementsTable.parentId, data.parentId),
                        eq(scorecardElementsTable.name, data.name)
                    ),
                });
                if (existingElement) {
                    return { isSuccess: false, message: "Element with this name already exists at this level." };
                }
            } else { // Top-level element check
                const existingElement = await db.query.scorecardElements.findFirst({
                    where: and(
                        eq(scorecardElementsTable.organizationId, data.organizationId),
                        eq(scorecardElementsTable.name, data.name),
                        eq(scorecardElementsTable.parentId, null)
                    ),
                });
                if (existingElement) {
                    return { isSuccess: false, message: "Top-level element with this name already exists in this organization." };
                }
            }

            const [newElement] = await db
              .insert(scorecardElementsTable)
              .values({
                ...data,
                ownerUserId: userId, // Assign current user as owner
              })
              .returning();

            return { isSuccess: true, message: "Scorecard element created successfully", data: newElement };
          } catch (error) {
            console.error("Error creating scorecard element:", error);
            return { isSuccess: false, message: "Failed to create scorecard element" };
          }
        }
        ```

*   **UC-101: Definir y Configurar KPI**
    *   **Funciones**: `createKpiAction`, `updateKpiConfigurationAction`.
    *   **Lógica**: Validar `scoring_type`, `calendar_frequency`, `data_type`, `aggregation_type`. Asegurar consistencia entre tipo de puntuación y tipo de dato (ej. no numérico con texto).
*   **UC-102: Configurar Actualizaciones Manuales de KPI**
    *   **Funciones**: `assignKpiUpdatersAction`, `updateKpiManualValueAction`.
    *   **Lógica**:
        *   Asignar `user_id` a `kpi_updaters` tabla.
        *   Para `updateKpiManualValueAction`, verificar si el usuario es un "Updater" del KPI.
        *   Registrar valores en `kpi_values` con `is_manual_entry = true`.
*   **UC-103: Configurar Cálculos Automáticos de KPI**
    *   **Funciones**: `setKpiCalculationEquationAction`.
    *   **Lógica**:
        *   Validar sintaxis de la ecuación y referencias a otros KPIs.
        *   Implementar un motor de cálculo que resuelva la ecuación al actualizar los KPIs referenciados. Considerar un mecanismo para detectar y prevenir bucles infinitos/dependencias circulares.
        *   Manejo de valores en blanco/N/A en ecuaciones (ej. tratar como 0 o N/A).
*   **UC-104: Asignar Propietarios a Elementos de Scorecard**
    *   **Funciones**: `assignScorecardElementOwnersAction`.
    *   **Lógica**: Actualizar el campo `owner_user_id` en `scorecard_elements`.
*   **UC-105: Gestionar Ponderación de Elementos de Scorecard**
    *   **Funciones**: `updateScorecardElementWeightAction`.
    *   **Lógica**:
        *   Actualizar el campo `weight` en `scorecard_elements`.
        *   Recalcular automáticamente los porcentajes de ponderación de los hermanos para la visualización.
        *   Asegurar que el cálculo de la puntuación agregada de los padres sea ponderado.
*   **UC-106: Auditar Cálculos de KPI y Puntuaciones**
    *   **Funciones**: `getKpiAuditTrailAction`.
    *   **Lógica**:
        *   Consultar `kpi_values` y `kpi_value_history` (si se implementa una tabla de historial explícita) para mostrar el origen del cálculo (manual, importado, calculado) y los valores de los KPIs referenciados.

### 5.2 Importación de Datos (actions/db/import-actions.ts)

*   **UC-200: Configurar Importación Simple de Valores de KPI (desde Hojas de Cálculo)**
    *   **Funciones**: `uploadSimpleKpiImportAction`.
    *   **Lógica**:
        *   Aceptar archivo Excel, parsear su contenido.
        *   Validar formato de archivo y coincidencia de KPIs/fechas.
        *   Actualizar `kpi_values` en lote.
        *   Registrar el historial de importación.
*   **UC-201: Configurar Importación Estándar de Valores de KPI (desde Hojas de Cálculo y Bases de Datos)**
    *   **Funciones**: `createSavedKpiImportAction`, `executeSavedKpiImportAction`.
    *   **Lógica**:
        *   Guardar configuración de importación en `saved_imports` (conexión, mapeos, transformaciones).
        *   `executeSavedKpiImportAction`: Conectarse a la fuente de datos (DB o archivo), ejecutar consulta/leer hoja, aplicar transformaciones, mapear a KPIs, actualizar `kpi_values`.
*   **UC-202: Gestionar Conexiones de Importación de Datos**
    *   **Funciones**: `createImportConnectionAction`, `updateImportConnectionAction`, `deleteImportConnectionAction`, `testImportConnectionAction`.
    *   **Lógica**:
        *   Almacenar `connection_details` en `import_connections`.
        *   **Cifrado de credenciales**: Las credenciales sensibles en `connection_details` (ej. contraseñas de DB) deben ser cifradas antes de su almacenamiento en la base de datos y descifradas para su uso. Utilizar una clave de cifrado generada por el servidor, almacenada de forma segura (ej. en variable de entorno `ENCRYPTION_KEY`).
        *   `testImportConnectionAction`: Establecer una conexión de prueba para verificar credenciales y acceso a la fuente.
        *   **Restricciones de seguridad**: Los administradores deben gestionar las conexiones de forma independiente de los usuarios normales para proteger la información del servidor.
*   **UC-203: Transformar Datos Durante la Importación**
    *   **Lógica**: La función `executeSavedKpiImportAction` debe invocar un módulo de transformación de datos que aplique las reglas (`transformations` JSONB) secuencialmente (limpieza, filtrado, expresiones regulares) antes de la carga final.
*   **UC-204: Programar Importaciones Recurrentes de KPI**
    *   **Funciones**: `scheduleKpiImportAction`, `unscheduleKpiImportAction`.
    *   **Lógica**:
        *   Almacenar `schedule_config` en `saved_imports`.
        *   **Vercel Cron Jobs**: Configurar un cron job en Vercel (ej. en `vercel.json` o `next.config.mjs`) para disparar una API route interna (ej. `/api/cron/run-scheduled-import`) en los intervalos definidos.
        *   Esta API route llamará a `executeSavedKpiImportAction` para la importación correspondiente.
        *   Manejo de fallos de ejecución programada (registrar errores y potencialmente enviar alertas).

### 5.3 Configuración de Alertas (actions/db/alert-actions.ts)

*   **UC-300: Configurar Alertas para KPIs en Estado "Rojo"**
    *   **Funciones**: `createKpiRedAlertAction`.
    *   **Lógica**:
        *   Crear una entrada en la tabla `alerts`.
        *   Un proceso en segundo plano (otra Vercel Cron Job) monitoreará periódicamente los KPIs y sus estados. Si un KPI cambia a "Rojo" y tiene una alerta configurada, se disparará una notificación.
        *   Envío de correos electrónicos vía SMTP.
*   **UC-301: Configurar Recordatorios de Actualización de KPI**
    *   **Funciones**: `configureKpiUpdateReminderAction`.
    *   **Lógica**: Similar a las alertas de KPI "Rojo", un cron job verificará KPIs no actualizados según su `calendar_frequency` y enviará recordatorios a los "Updaters".
*   **UC-302: Habilitar Alertas por Respuestas a Notas**
    *   **Funciones**: `configureNoteReplyAlertAction`.
    *   **Lógica**: Cuando se añade una nota a `kpi_values` (o una tabla de notas general si se implementa) y se identifica una "respuesta", se dispara una alerta al autor original.
*   **UC-303: Requerir Nota al Actualizar KPI a Bajo Rendimiento**
    *   **Funciones**: `toggleRequireNoteForRedKpiAction`.
    *   **Lógica**:
        *   Almacenar esta configuración en `app_settings`.
        *   En `updateKpiManualValueAction`, si el KPI pasa a "Rojo" y la configuración está activada, se validará que el campo `note` en `kpi_values` no esté vacío.
*   **UC-304: Crear Alertas Personalizadas para Cambios de KPI**
    *   **Funciones**: `createCustomKpiAlertAction`.
    *   **Lógica**: Permitir al usuario definir condiciones (`condition_details` JSONB) más complejas para el disparo de alertas (ej. "cuando el valor supera X", "cuando la puntuación cae por debajo de Y"). El proceso de monitoreo de cron jobs evaluará estas condiciones.

### 5.4 Administración de Usuarios, Grupos y Permisos (actions/db/user-group-actions.ts)

*   **UC-400: Gestionar Usuarios Individuales**
    *   **Funciones**: `createUserAction`, `updateUserAction`, `deactivateUserAction`.
    *   **Lógica**: Clerk gestiona la mayoría de los detalles del usuario. Estas acciones interactuarán con la API de Clerk y la tabla `profiles` para metadatos adicionales y activación/desactivación.
*   **UC-401: Importar Usuarios Masivamente**
    *   **Funciones**: `bulkImportUsersAction`.
    *   **Lógica**: Parsear archivo Excel, invocar la API de Clerk para crear/actualizar usuarios en lote. Asignar usuarios a grupos si se especifica en el archivo.
*   **UC-402: Crear y Gestionar Grupos de Usuarios y Permisos**
    *   **Funciones**: `createGroupAction`, `updateGroupAction`, `deleteGroupAction`, `assignGroupMembersAction`, `assignGroupPermissionsAction`.
    *   **Lógica**:
        *   CRUD para la tabla `groups`.
        *   Gestión de miembros en `group_members`.
        *   Asignación de permisos (`permission_key`, `permission_value`, `organization_id`) en `group_permissions`.
        *   **Tipos de grupo predefinidos**: `Power Users`, `Update Users`, `Interactive Users`, `View Only` tendrán un conjunto base de permisos.
*   **UC-403: Personalizar Terminología de la Aplicación**
    *   **Funciones**: `updateTerminologyAction`.
    *   **Lógica**: Actualizar `app_settings` con los términos personalizados. Estos términos se cargarán en la capa de UI.
*   **UC-404: Activar/Desactivar Strategy Maps**
    *   **Funciones**: `toggleStrategyMapsAction`.
    *   **Lógica**: Actualizar `app_settings` para controlar la visibilidad de la funcionalidad "Strategy Maps" en la UI.

### 5.5 Organizaciones (actions/db/organization-actions.ts)

*   **UC-500: Configurar Jerarquía de Organizaciones**
    *   **Funciones**: `createOrganizationAction`, `updateOrganizationAction`, `deleteOrganizationAction`, `reorderOrganizationAction`.
    *   **Lógica**:
        *   CRUD para `organizations`.
        *   Manejo de la relación `parent_id` para la jerarquía.
        *   Prevenir referencias circulares en la jerarquía.
*   **UC-501: Implementar KPIs de Rollup entre Organizaciones**
    *   **Funciones**: `enableKpiRollupAction`.
    *   **Lógica**:
        *   Cuando se activa `rollup_enabled` para un KPI padre, su valor se calculará automáticamente agregando los valores de KPIs con el mismo nombre en las organizaciones hijas, utilizando el `aggregation_type` especificado (Suma, Promedio).
        *   Este cálculo se disparará automáticamente cuando los KPIs hijos sean actualizados o mediante un cron job de re-cálculo periódico.
*   **UC-502: Configurar Organizaciones Basadas en Plantillas desde Datasets**
    *   **Funciones**: `createTemplatedOrganizationsFromDatasetAction`.
    *   **Lógica**:
        *   Recibir un `organization_id` (plantilla), un `dataset_id` y un `field_name`.
        *   Iterar sobre los valores únicos del `field_name` en el dataset.
        *   Para cada valor, crear una nueva organización hija (copiando la estructura de Scorecard y los KPIs de la plantilla) en la tabla `organizations`.
        *   Si los KPIs de la plantilla son "dataset KPIs" (se actualizan desde el dataset), se configurarán con filtros específicos para la nueva organización.
*   **UC-503: Integrar Permisos Organizacionales con Grupos de Árboles de Rollup**
    *   **Funciones**: `assignRollupTreeGroupPermissionsAction`.
    *   **Lógica**:
        *   Al asignar un "grupo de árbol de rollup" a una organización (normalmente una plantilla), esta acción creará entradas en `group_permissions` que vinculan al grupo con la organización y sus descendientes.
        *   Cuando un usuario inicia sesión, la lógica de autorización verificará la pertenencia del usuario a estos grupos y filtrará la información visible (organizaciones y KPIs) para mostrar solo lo permitido por su nivel en el árbol de rollup y sus descendientes.

## 6. Sistema de Diseño y Arquitectura de Componentes

### 6.1 Componentes UI

Se utilizará **Shadcn/UI** para la mayoría de los componentes de interfaz de usuario. Los componentes de Shadcn/UI se encuentran en `components/ui/` y **no deben ser modificados directamente**.

### 6.2 Componentes Compartidos

Componentes reutilizables a nivel de aplicación (ej. `Header`, `Footer`) se ubicarán en `components/`.

### 6.3 Componentes Específicos de Ruta

Componentes que solo se utilizan en una ruta específica se ubicarán en el subdirectorio `_components` dentro de esa ruta (ej. `app/(marketing)/contact/_components/contact-form.tsx`).

### 6.4 Iconografía

Todos los iconos provendrán de la librería `lucide-react`.

### 6.5 Estilos

Todos los estilos se manejarán con **Tailwind CSS**. Se seguirán las convenciones de `className` y `@apply` para aplicar estilos.

### 6.6 Animaciones

Se utilizará **Framer Motion** para animaciones fluidas y mejoras de la experiencia de usuario. Esto incluye transiciones de entrada/salida para modales y elementos clave de la UI.

## 7. Autenticación y Autorización

### 7.1 Autenticación (Clerk)

*   **Proveedor**: Clerk para autenticación, registro y gestión de sesiones.
*   **Rutas de Autenticación**: Las rutas de inicio de sesión (`/login`) y registro (`/signup`) están configuradas con los componentes de Clerk.
*   **Protección de Rutas**: El middleware de Clerk en `middleware.ts` protegerá las rutas sensibles de la aplicación (ej. el grupo `/(main)`). Los usuarios no autenticados serán redirigidos a la página de inicio de sesión.
*   **Sincronización de Perfiles**: En `app/layout.tsx`, se verificará si el `userId` de Clerk tiene un perfil asociado en la tabla `profiles`. Si no existe, se creará un nuevo perfil automáticamente.

### 7.2 Autorización (Roles y Permisos)

*   **Modelo Basado en Roles**: Se definen cuatro tipos de grupos de usuarios en `groups.group_type`:
    *   **Power Users**: Acceso completo a la configuración y gestión de la plataforma.
    *   **Update Users**: Permisos para actualizar valores de KPI (serán los `Updaters`).
    *   **Interactive Users**: Permisos para visualizar datos, interactuar con Scorecards y dejar notas.
    *   **View Only**: Solo permisos de visualización.
*   **Permisos Granulares por Grupo**: La tabla `group_permissions` almacenará los permisos específicos asignados a cada grupo (`permission_key`, `permission_value`).
*   **Permisos Organizacionales**: Se implementarán permisos basados en la jerarquía de organizaciones (`organization_id` en `group_permissions`). Esto permitirá que los usuarios o grupos solo vean datos de su organización asignada y sus descendientes. La funcionalidad de "grupos de árboles de rollup" se utilizará para una gestión escalable de permisos basada en la estructura jerárquica.
*   **Validación de Permisos**: Todas las Server Actions realizarán verificaciones de permisos al inicio para asegurar que el usuario autenticado tiene la autorización necesaria para realizar la operación solicitada. Esto incluirá la verificación de pertenencia a grupos y permisos organizacionales.

## 8. Flujo de Datos y Gestión del Estado

### 8.1 Fetching de Datos

*   **Server Components**: La estrategia principal para la obtención de datos será el uso de Server Components de Next.js. Estos componentes interactuarán directamente con Drizzle ORM o Server Actions para obtener datos de la base de datos de manera eficiente.
*   **Props Down**: Los datos obtenidos en los Server Components se pasarán como props a los Client Components descendientes.
*   **Optimización**: Se implementará `Suspense` para manejar los estados de carga durante la obtención de datos asíncrona en Server Components.

### 8.2 Mutación de Datos

*   **Server Actions**: Las operaciones de creación, actualización y eliminación de datos se manejarán exclusivamente a través de Server Actions. Esto asegura que la lógica de negocio y las interacciones con la base de datos ocurran de forma segura en el servidor.
*   **`ActionState`**: Todas las Server Actions devolverán un tipo `ActionState<T>` para proporcionar un feedback consistente sobre el éxito o fracaso de la operación, junto con un mensaje y, si aplica, los datos resultantes.

### 8.3 Gestión de Estado en el Cliente

*   **React Hooks**: `useState` y `useEffect` se utilizarán para gestionar el estado local de los componentes de UI.
*   **Formularios**: `react-hook-form` con `zod` para validación de esquemas se utilizará para la gestión de formularios.
*   **Revalidación**: Después de ejecutar una Server Action que modifica datos, se utilizarán métodos como `router.refresh()` o la re-ejecución de Server Components para asegurar que la UI muestre los datos más actualizados.
*   **Notificaciones**: El sistema `useToast` de Shadcn/UI (`components/ui/toaster.tsx` y `components/ui/use-toast.ts`) se utilizará para mostrar mensajes al usuario (éxito, error, información).

## 9. Implementación de Pagos

### 9.1 Integración Stripe

*   **Stripe SDK**: La biblioteca `stripe` de Node.js se utilizará en el backend (`lib/stripe.ts`).
*   **Webhooks**: Se configurará un endpoint de webhook de Stripe en `/api/stripe/webhooks/route.ts`. Este endpoint escuchará eventos relevantes de Stripe (ej. `checkout.session.completed`, `customer.subscription.updated`, `customer.subscription.deleted`).
*   **Sincronización de Suscripciones**: Las Server Actions `manageSubscriptionStatusChange` y `updateStripeCustomer` (en `actions/stripe-actions.ts`) serán invocadas por el webhook para actualizar el estado de membresía del usuario (`profiles.membership`) y los IDs de cliente/suscripción de Stripe en la tabla `profiles` de la base de datos.
*   **Página de Precios**: La página `/pricing` (`app/(marketing)/pricing/page.tsx`) generará enlaces de pago de Stripe. Estos enlaces incluirán el `userId` como `client_reference_id` para vincular la sesión de checkout con el usuario en Clerk.

## 10. Implementación de Analíticas

Basado en la información proporcionada en los documentos de origen, **no se ha especificado la implementación de un sistema de analíticas externo** para el seguimiento del comportamiento del usuario o la telemetría de la aplicación. La "visibilidad mejorada del rendimiento" y la "toma de decisiones más informada" se refieren a los resultados de las funcionalidades internas de Scorecard y KPI de DeltaOne.

Si en el futuro se requiriera un seguimiento analítico, se consideraría la integración de herramientas como Google Analytics, PostHog o un sistema de logging estructurado para eventos específicos.

## 11. Estrategia de Pruebas

Aunque las fuentes no detallan una estrategia de pruebas explícita, se establecerán las siguientes directrices para asegurar la calidad del software, como se menciona en el `CONTRIBUTING.md`:

*   **Pruebas Unitarias**:
    *   **Alcance**: Funciones puras, Server Actions (lógica de negocio y llamadas a Drizzle), funciones de utilidad.
    *   **Herramientas**: Jest/Vitest.
    *   **Mocking**: Se mokearán las dependencias externas (ej. `db` de Drizzle, funciones de Clerk, `stripe` SDK) para aislar la lógica bajo prueba.
*   **Pruebas de Integración**:
    *   **Alcance**: Interacciones entre Server Actions y la base de datos, flujos que involucran múltiples componentes de UI y sus interacciones con Server Actions.
    *   **Herramientas**: Jest/Vitest.
    *   **Estrategia**: Se utilizará una base de datos de prueba separada o contenedores Docker (ej. Testcontainers) para simular un entorno de base de datos real.
*   **Pruebas End-to-End (E2E)**:
    *   **Alcance**: Recorridos completos del usuario a través de la interfaz de usuario, validando la integración de frontend, backend y base de datos. Se priorizarán los flujos críticos (ej. registro, inicio de sesión, creación y actualización de KPI, importación de datos).
    *   **Herramientas**: Playwright.
    *   **Estrategia**: Se ejecutarán estas pruebas en un entorno de prueba que simule lo más fielmente posible el entorno de producción.
*   **Validación de Esquemas y Tipos**:
    *   Se ejecutará `npm run type-check` (`tsc --noEmit`) para asegurar la coherencia de tipos en todo el proyecto.
    *   Se utilizará `zod` para la validación de esquemas de entrada en los formularios y Server Actions.
*   **Calidad de Código**:
    *   ESLint (`npm run lint`) y Prettier (`npm run format:write`) se utilizarán para mantener la consistencia del código y el estilo.
    *   Hooks de pre-commit con Husky (`.husky/pre-commit`) para ejecutar `lint:fix` y `format:write` antes de cada commit.